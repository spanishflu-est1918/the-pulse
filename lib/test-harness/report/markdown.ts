/**
 * Markdown Report Generator
 *
 * Generate formatted markdown reports from session data.
 */

import { writeFile } from 'node:fs/promises';
import type { SessionResult } from '../session/runner';
import type { Message } from '../session/turn';
import type { SessionFeedback } from '../session/feedback';
import type { GameState } from '../session/state';
import { detectAllIssues } from './issues';
import {
  generateTimeline,
  formatTimelineMarkdown,
  getTimelineSummary,
} from './timeline';
import { saveHTMLReport } from './html';

export interface SessionReport {
  config: {
    story: string;
    narrator: string;
    prompt: string;
    duration: number;
    cost: number;
  };
  group: Array<{ name: string; archetype: string; model: string }>;
  summary: {
    turns: number;
    pulsesDetected: number;
    pulsesExpected: number;
    tangentCount: number;
    avgTangentLength: number;
    privateMoments: number;
    issuesFound: number;
    outcome: string;
  };
  timeline: string;
  issues: string;
  transcript: string;
}

/**
 * Generate complete session report
 */
export async function generateSessionReport(
  result: SessionResult,
): Promise<string> {
  const issues = await detectAllIssues(
    result.conversationHistory,
    result.detectedPulses,
  );
  const timeline = generateTimeline(
    result.conversationHistory,
    result.detectedPulses,
    result.privateMoments,
    issues,
  );
  const timelineSummary = getTimelineSummary(timeline);

  const report = `# Session Report

## Configuration

- **Session ID**: ${result.sessionId}
- **Story**: ${result.config.story.storyTitle}
- **Narrator**: ${result.config.narratorConfig.model}
- **Duration**: ${formatDuration(result.duration)}
- **Outcome**: ${result.outcome}
- **Cost**: ${result.costBreakdown ? `$${result.costBreakdown.total.cost.toFixed(4)}` : `$${estimateCost(result).toFixed(2)} (estimated)`}

## Group

| Player | Archetype | Model |
|--------|-----------|-------|
${result.config.group.players
  .map(
    (p) =>
      `| ${p.name} ${p.name === result.config.group.spokesperson.name ? '(spokesperson)' : ''} | ${p.archetype} | ${p.model} |`,
  )
  .join('\n')}

## Summary

- **Turns**: ${result.finalTurn} (total exchanges)
- **Pulses**: ${result.detectedPulses.length}/~20 (story beats that advanced narrative)
- **Tangents**: ${timelineSummary.tangents}
- **Private Moments**: ${timelineSummary.privateMoments}
- **Issues Detected**: ${issues.length}

${
  result.costBreakdown
    ? `## Cost Breakdown

| Component | Tokens (Input/Output) | Cost |
|-----------|----------------------|------|
| Narrator | ${result.costBreakdown.narrator.tokens.promptTokens.toLocaleString()}/${result.costBreakdown.narrator.tokens.completionTokens.toLocaleString()} | $${result.costBreakdown.narrator.cost.toFixed(4)} |
| Players | ${result.costBreakdown.players.tokens.promptTokens.toLocaleString()}/${result.costBreakdown.players.tokens.completionTokens.toLocaleString()} | $${result.costBreakdown.players.cost.toFixed(4)} |
| Classification | ${result.costBreakdown.classification.tokens.promptTokens.toLocaleString()}/${result.costBreakdown.classification.tokens.completionTokens.toLocaleString()} | $${result.costBreakdown.classification.cost.toFixed(4)} |
| **Total** | **${result.costBreakdown.total.tokens.totalTokens.toLocaleString()}** | **$${result.costBreakdown.total.cost.toFixed(4)}** |
`
    : ''
}

## Timeline

${formatTimelineMarkdown(timeline)}

${
  issues.length > 0
    ? `## Issues Detected

${formatIssues(issues)}`
    : '## No Issues Detected âœ“'
}

${formatGameState(result.gameState)}

${result.playerFeedback ? formatPlayerFeedback(result.playerFeedback) : ''}

## Full Transcript

${formatTranscript(result.conversationHistory)}

---

*Generated by The Pulse Test Harness*
*Session completed: ${new Date(result.config.createdAt).toISOString()}*
`;

  return report;
}

/**
 * Save report to file
 */
export async function saveSessionReport(
  result: SessionResult,
  filename?: string,
): Promise<string> {
  const report = await generateSessionReport(result);
  const filepath = filename || `sessions/${result.sessionId}/report.md`;

  await writeFile(filepath, report, 'utf-8');

  // Also generate HTML report
  try {
    await saveHTMLReport(result);
  } catch (error) {
    console.warn('Failed to generate HTML report:', error);
  }

  return filepath;
}

/**
 * Format duration in human-readable format
 */
function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`;
  } else if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  } else {
    return `${seconds}s`;
  }
}

/**
 * Estimate cost based on usage
 * Note: Actual token tracking is implemented in session/cost.ts
 */
function estimateCost(result: SessionResult): number {
  // Rough estimates based on model pricing
  const narratorCostPerTurn =
    result.config.narratorConfig.model === 'opus-4.5' ? 0.15 : 0.02;
  const playerCostPerTurn = 0.01;

  return (
    result.finalTurn *
    (narratorCostPerTurn + playerCostPerTurn * result.config.group.size)
  );
}

/**
 * Format issues for markdown
 */
function formatIssues(issues: any[]): string {
  return issues
    .map(
      (issue) => `
### Turn ${issue.turn}: ${issue.type.toUpperCase()} (${issue.severity})

${issue.description}

${issue.relatedContent ? `> ${issue.relatedContent}` : ''}
`,
    )
    .join('\n');
}

/**
 * Format player feedback for markdown
 */
function formatPlayerFeedback(feedback: SessionFeedback): string {
  const playerFeedbackSections = feedback.players
    .map(
      (p) => `
### ${p.agentName} (${p.archetype})

**Highlight**: ${p.highlight.moment}
> ${p.highlight.reason}

**Agency**: ${p.agency.feltMeaningful ? 'âœ“ Felt meaningful' : 'âœ— Did not feel meaningful'}
> ${p.agency.example}

**Pacing**: ${p.pacing.rating === 'good' ? 'âœ“ Good' : p.pacing.rating === 'too-fast' ? 'âš¡ Too fast' : 'ðŸŒ Too slow'}
> ${p.pacing.notes}

**Narrator Rating**: ${p.narratorRating.score}/10
- Positives: ${p.narratorRating.positives.join(', ') || 'None mentioned'}
- Negatives: ${p.narratorRating.negatives.join(', ') || 'None mentioned'}

**Frustrations**: ${p.frustrations.length > 0 ? p.frustrations.map((f) => `\n- ${f}`).join('') : 'None'}

**Missed Opportunities**: ${p.missedOpportunities.length > 0 ? p.missedOpportunities.map((m) => `\n- ${m}`).join('') : 'None'}

**Group Dynamics**: ${p.groupDynamics}
`,
    )
    .join('\n---\n');

  return `## Player Feedback

### Summary

- **Narrator Score**: ${feedback.narratorScore.toFixed(1)}/10
- **Pacing**: ${feedback.pacingVerdict}

**Top Moments**:
${feedback.topMoments.map((m) => `- ${m}`).join('\n')}

**Shared Pain Points**:
${feedback.sharedPainPoints.length > 0 ? feedback.sharedPainPoints.map((p) => `- ${p}`).join('\n') : '- None'}

**Narrator Strengths**:
${feedback.narratorStrengths.length > 0 ? feedback.narratorStrengths.map((s) => `- ${s}`).join('\n') : '- None mentioned'}

**Narrator Weaknesses**:
${feedback.narratorWeaknesses.length > 0 ? feedback.narratorWeaknesses.map((w) => `- ${w}`).join('\n') : '- None mentioned'}

**Recommendations**:
${feedback.recommendations.length > 0 ? feedback.recommendations.map((r) => `- ${r}`).join('\n') : '- None'}

### Individual Player Feedback

${playerFeedbackSections}
`;
}

/**
 * Format game state for markdown
 */
function formatGameState(gameState?: GameState): string {
  if (!gameState || gameState.characters.length === 0) {
    return `## Game State

*No character mappings extracted*
`;
  }

  const characterTable = `| Player (OD) | Character (ID) | Role | Items |
|-------------|----------------|------|-------|
${gameState.characters
  .map(
    (c) =>
      `| ${c.odName} | ${c.idName} | ${c.role} | ${c.items.length > 0 ? c.items.join(', ') : '-'} |`,
  )
  .join('\n')}`;

  const npcs =
    gameState.npcsEncountered.length > 0
      ? `\n**NPCs Encountered**: ${gameState.npcsEncountered.join(', ')}`
      : '';

  const flags = Object.keys(gameState.plotFlags).length > 0
    ? `\n**Plot Flags**: ${Object.entries(gameState.plotFlags)
        .map(([k, v]) => `${k}=${v}`)
        .join(', ')}`
    : '';

  return `## Game State

### Character Mappings (Locked after Turn 1)

${characterTable}

**Final Location**: ${gameState.location}${npcs}${flags}
`;
}

/**
 * Format transcript for markdown
 */
function formatTranscript(messages: Message[]): string {
  return messages
    .map((m) => {
      const speaker =
        m.role === 'narrator'
          ? '**Narrator**'
          : m.role === 'spokesperson'
            ? `**Spokesperson (${m.player})**`
            : `**${m.player}**`;

      return `### Turn ${m.turn} - ${speaker}

${m.content}

${m.classification ? `*[Classified as: ${m.classification}]*` : ''}
`;
    })
    .join('\n---\n\n');
}
