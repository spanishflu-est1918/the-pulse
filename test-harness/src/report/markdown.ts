/**
 * Markdown Report Generator
 *
 * Generate formatted markdown reports from session data.
 */

import { writeFile } from 'node:fs/promises';
import type { SessionResult } from '../session/runner';
import type { Message } from '../session/turn';
import { detectAllIssues } from './issues';
import { generateTimeline, formatTimelineMarkdown, getTimelineSummary } from './timeline';

export interface SessionReport {
  config: {
    story: string;
    narrator: string;
    prompt: string;
    duration: number;
    cost: number;
  };
  group: Array<{ name: string; archetype: string; model: string }>;
  summary: {
    turns: number;
    pulsesDetected: number;
    pulsesExpected: number;
    tangentCount: number;
    avgTangentLength: number;
    privateMoments: number;
    issuesFound: number;
    outcome: string;
  };
  timeline: string;
  issues: string;
  transcript: string;
}

/**
 * Generate complete session report
 */
export async function generateSessionReport(result: SessionResult): Promise<string> {
  const issues = detectAllIssues(result.conversationHistory, result.detectedPulses);
  const timeline = generateTimeline(
    result.conversationHistory,
    result.detectedPulses,
    result.privateMoments,
    issues,
  );
  const timelineSummary = getTimelineSummary(timeline);

  const report = `# Session Report

## Configuration

- **Session ID**: ${result.sessionId}
- **Story**: ${result.config.story.storyTitle}
- **Narrator**: ${result.config.narratorConfig.model}
- **System Prompt**: ${result.config.systemPrompt.substring(0, 50)}...
- **Duration**: ${formatDuration(result.duration)}
- **Outcome**: ${result.outcome}
- **Cost**: $${estimateCost(result).toFixed(2)} (estimated)

## Group

| Player | Archetype | Model |
|--------|-----------|-------|
${result.config.group.players
  .map((p) => `| ${p.name} ${p.name === result.config.group.spokesperson.name ? '(spokesperson)' : ''} | ${p.archetype} | ${p.model} |`)
  .join('\n')}

## Summary

- **Turns**: ${result.finalTurn}
- **Pulses Detected**: ${result.detectedPulses.length}/~20
- **Tangents**: ${timelineSummary.tangents}
- **Private Moments**: ${timelineSummary.privateMoments}
- **Issues Detected**: ${issues.length}

## Timeline

${formatTimelineMarkdown(timeline)}

${
  issues.length > 0
    ? `## Issues Detected

${formatIssues(issues)}`
    : '## No Issues Detected âœ“'
}

## Full Transcript

${formatTranscript(result.conversationHistory)}

---

*Generated by The Pulse Test Harness*
*Session completed: ${new Date(result.config.createdAt).toISOString()}*
`;

  return report;
}

/**
 * Save report to file
 */
export async function saveSessionReport(
  result: SessionResult,
  filename?: string,
): Promise<string> {
  const report = await generateSessionReport(result);
  const filepath = filename || `sessions/${result.sessionId}/report.md`;

  await writeFile(filepath, report, 'utf-8');

  return filepath;
}

/**
 * Format duration in human-readable format
 */
function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`;
  } else if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  } else {
    return `${seconds}s`;
  }
}

/**
 * Estimate cost based on usage
 * TODO: Implement accurate token tracking
 */
function estimateCost(result: SessionResult): number {
  // Rough estimates based on model pricing
  const narratorCostPerTurn = result.config.narratorConfig.model === 'opus-4.5' ? 0.15 : 0.02;
  const playerCostPerTurn = 0.01;

  return result.finalTurn * (narratorCostPerTurn + playerCostPerTurn * result.config.group.size);
}

/**
 * Format issues for markdown
 */
function formatIssues(issues: any[]): string {
  return issues
    .map(
      (issue) => `
### Turn ${issue.turn}: ${issue.type.toUpperCase()} (${issue.severity})

${issue.description}

${issue.relatedContent ? `> ${issue.relatedContent}` : ''}
`,
    )
    .join('\n');
}

/**
 * Format transcript for markdown
 */
function formatTranscript(messages: Message[]): string {
  return messages
    .map((m) => {
      const speaker =
        m.role === 'narrator'
          ? '**Narrator**'
          : m.role === 'spokesperson'
            ? `**Spokesperson (${m.player})**`
            : `**${m.player}**`;

      return `### Turn ${m.turn} - ${speaker}

${m.content}

${m.classification ? `*[Classified as: ${m.classification}]*` : ''}
`;
    })
    .join('\n---\n\n');
}
